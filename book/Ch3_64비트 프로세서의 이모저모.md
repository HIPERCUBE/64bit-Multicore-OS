# 64비트 프로세서의 이모저모

## Index
 - 운영모드
 - 운영모드와 레지스터
 - 운영모드와 메모리 관리기법

## 운영모드
인텔 64비트 호환 프로세서(이하 x86-64 프로세서)에서는 크게 다섯가지 운영모드가 있다.
우릭에게 친숙하 16비트의 리얼 모드, 32비트 보호 모드, 64비트의 IA-32e 모드, 시스템 관리 모드, 가상 8086 모드가 있다.
각 모드는 컨트롤 레지스터와 인터럽트라는 특수한 이벤트를 통해 각 모드로 전환할 수 있다.

| 운영 모드 | 설명 |
| :-------: | :--- |
| 리얼 모드 | 프로세서의 초기 상태로서 16비트 모드로 동작<br/>최대 1MB의 주소 공간 지원 |
| 보호 모드 | 32비트 모드로 동작하며 세그먼트, 페이징, 보호, 멀티태스킹 등의 기능 제공<br/>4GB 주소 공간 지원 |
| IA-32e 모드 | 32비트 호환 모드와 64비트 모드의 두 가지 서브모드로 구성<br/>16EB의 주소 공간 지원 |
| 시스템 관리 모드 | 전원 관리나 하드웨어 제어 같은 특수 가능을 제공하는 모드 |
| 가상 8086 모드 | 보호 모드 내부에서 가상의 환경을 설정하여 리얼 모드처럼 동작하는 모드 |

x86-64 프로세서는 위와 같이 총 다섯 가지 운영 모드 지원하지만, 위 운영 모드를 모두 구현해야 OS를 개발할 수 있는건 아니다.
64 비트 OS가 반드시 지원해야 하는 모드는 **리얼모드**, **보호 모드**, **IA-32e모드 중 64비트 서브모드**이다.
나머지 다른 모드는 특수한 상황에서만 사용되므로 반드시 구현할 필요는 없다.

### 리얼 모드
프로세서가 전원이 켜지거나 리셋되면 가장 먼저 리얼모드로 진입한다.
리얼모드는 과거의 16비트 프로세서와 동일하게 동작하며, 이후에 설명할 BIOS(Basic Input Output System)의 여러 기능을 사용할 수 있다.
리얼 모드는 디바이스 드라이버를 제작하지 않아도 되는 장점이 있고, 하는 작업도 OS 이미지를 디스크에서 메모리로 복사하여 보호 모드로 변경하는 것 밖에 없지만, 대부분 작업을 어셈블리어로 처리해야 한다는 단점이 있다.

### 보호 모드
보호 모드는 IA-32e 모드로 전환하려면 공식적으로 거쳐야 하는 모드로, 32비트 윈도우나 리눅스 OS가 동작하는 기본 모드입니다.
최대 4GB의 주소 공간을 제공하며 OS의 필수 기능으로 자리 잡은 보호, 멀티태스킹, 세그먼테이션, 페이징 등의 기능을 하드웨어적으로 지원한다.
여러 기능을 제공하는 만큼 복잡하고, 레지스터와 자료구조가 다양하다.

### IA-32e 모드
IA-32e 모드에는 서브모드로 32비트 호환 모드와 64비트 모드가 있다.
32비트 호환 모드는 보호 모드와 같은 기능을 수행하므로 64비트 모드를 위주로 살펴보겠다.
IA-32e 모드는 최대 16EBd의 주소 공간을 제공하며 레지스터 수도 보호 모드보다 많다.
다만 자료 구조는 더 복잡하지 않고 대부분 보호 모드와 같거나 크지만 2배로 확장되고 일부 필드의 의미가 변하는 정도이므로 보호 모드와 큰 차이는 없다.
한가지 재미있는 사실은 프로세서가 32비트 호환 모드일 때는 보호모드에 있는 것처럼 동작하므로 32비트 코드를 그대로 실행할 수 있다는 점이다.
64비트 OS에서 32비트 보호 모드 코드를 별다른 처리 없이 그대로 실행할 수 있는 것도 이러한 서브모드를 사용하기 때문이다.

### 운영 모드 사이의 관계와 운영 모드의 전환
특정 모드에서 다른 모드로 전환하는 작업은 현재 동작 중인 모드에 따라 차이가 있다.
리얼 모드에서 보호 모드로 전환하는 상황처럼 다른 모드를 거치지 않고 바로 전환 가능한 경우도 있지만 리얼모드에서 IA-32e모드로 전환하는 상황과 같이 리얼모드 -> 보호모드 -> IA-32 모드를 거쳐서 전환해야 하는 경우도 있다.

![](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/book/img/Ch3_img1.png)

위 그림의 화살표 위에 표시된 내용은 해당 모드로 전환하는데 필요한 조건을 나타낸 것이다.
조건에는 컨트롤 레지스터와 인터럽트 발생만 표시되어 있지만, 기본적으로 각 모드에 필요한 자료구조는 미리 설정되어 있어야 한다.
화살표가 연결되지 않은 리얼모드에서 IA-32e 모드로 전환하는 것은 불가능하며, 무리하게 시도하면 리셋이나 예외가 발생할 수 있다.
(실제 편법을 사용하면 가능하긴 하지만 여기서는 다루지 않는다.)


## 운영 모드와 레지스터
OS를 개발하는 관점에서 운용 모드는 크게 16비트 모드, 32비트 모드, 64비트 모드 세 가지로 나눌 수 있다.
운영 모드 앞에 붙은 숫자는 레지스터의 크기와 관계가 있으며 숫자가 커질수록 레지스터의 개수도 많아진다.

![](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/book/img/Ch3_img2.png)

보호모드에서의 레지스터


![](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/book/img/Ch3_img3.png)

IA-32e모드에서의 레지스터


x86-64 프로세서에는 위 그림들과 같이 많은 레지스터가 있지만, OS를 개발하는 과정에서 큰 비중을 차지하는 **범용 레지스터**, **세그먼트 레지스터**, **컨트롤 레지스터** 세 가지이다.

### 범용 레지스터
범용 레지스터(General Purpose Register)는 운영 모드와 가장 관계가 깊은 레지스터이다.
범용 레지스터는 계산, 메모리 어드레스 지정, 임시 저장 공간 등의 목적으로 사용한다.
범용 레지스터 수는 프로세서가 지원하는 운영 모드에 따라 다르다.
16비트와 32비트 모드를 지원하는 x86 계열은 8개, 64비트 모드를 지원하는 x86-64 계열은 16개의 범용 레지스터가 있다.

범용 레지스터 수가 늘어나면 메모리에 접근하는 시간을 줄임으로서 수행 속도가 개선될 수 있다는 장점이 있다.
이와 비슷한 효과는 함수 호출에도 그대로 적용된다.
다수의 범용 레지스터에 함수 파라미터를 넣어 넘겨줌으로서 스택 영역의 메모리에 접근하는 시간과 스택을 정리하는 시간을 줄일 수 있다.

이름에서 알 수 있듯이 범용 레지스터의 용도는 고정된 것이 아니며, 다양한 목적으로 사용될 수 있다.
x86-64 프로세서는 x86 프로세서가 가지는 범용 레지스터 외에도 R8~R15로 이름 붙여진 8개의 레지스터가 더 있다.
이 레지스터의 기능은 다른 범용 레지스터와 같으며 차이점이라면 특수한 용도가 정의되지 않았다는 것이다.

| 범용 레지스터 명 | 용도 |
| :--: | :-- |
| AX | 산순 연산을 수행할 때 누산기로 사용 (Accumulate) |
| BX | 데이터의 어드레스를 지정할 때 데이터 포인터로 사용 (Base) |
| CX | 루프 혹은 문자열의 카운터로 사용 (Count) |
| DX | I/O Address 지정할 때 사용, 산술 연산을 수행할 때 보조 레지스터 (Data) |
| SI | 문자열을 작업 진행 시 원본 문자열의 인덱스 (Source Index) |
| DI | 문자열을 작업 진행 시 목적 문자열의 인덱스 (Destination Index) |
| SP | 스택의 포인터로 사용 (Stack Pointer) |
| BP | 스택의 데이터에 접근할 때 데이터의 포인터로 사용 (Base Pointer) |
| R8~R15 | x86-64 프로세서에 추가된 범용 레지스터로, 다양한 용도로 사용 |

레지스터가 특수한 용도로 사용되는 예로 PC에 연결된 디바이스를 제어하려면 장치가 연결된 I/O 어드레스에 접근해야 한다.
이때 I/O어드레스를 저장할 수 있는 레지스터는 DX를 통해서만 가능하다.
또 다른 예는 정수 곱셈 코드에서 찾을 수 있다.
곱셈 명령은 오퍼랜드가 하나밖에 없는데 이것이 가능한 이유는 곱셈 명령이 다른 하나의 오퍼랜드로 AX레지스터를 사요하기 때문이다.
곱셈 명령은 AX와 오퍼랜드를 곱한 후, 그 결과를 DX:AX, 혹은 AX에 저장하도록 설계되어있다.

64비트 범용 레지스터는 하위 32비트, 16비트, 8비트의 크기로 구분하여 접근할 수 있고, 레지스터에 접두사(Prefix)나 접미사(Postfix)를 붙여 접근하는 크기를 표시한다.
대체로 64비트 레지스터에는 RAX, RBX처럼 R 접두사가 붙고, 32비트 레지스터에는 EAX, EBX, E8D, R9D처럼 E접두사나 D접미사가 붙는다.
16비트 레지스터는 AX, BX, R8W, R9W처럼 접두사가 붙지 않거나 W접미사가 붙는다.
16비트 이하의 레지스터는 상위 8비트와 하위 8비트로 다시 구분되는데 상위 8비트는 AH, BH처럼 끝자리가 H로 변경되고, 하위 8비트는 AL, BL, SIL, DIL, R8L, R9L처럼 끝자리가 L로 변경되거나 접미사 L이 붙는다.

리얼 모드에서 16비트 크기 이하의 레지스터만 접근 가능한 것으로 되어 있지만, 오퍼랜드 크기 접두사(Operand-Size Prefix, 0x66)를 사용하거나 어드레스 크기 접두사(Address-Size Prefix, 0x67)를 사용하면 32비트 레지스터도 접근할 수 있지만, 이런 경우는 보호 모드로 전환하는 것처럼 특수한 상황이므로 리얼 모드에서 16비트 이하의 크기를 가지는 레지스터에만 접근한다고 생각해도 된다.
운영 모드에 따라 접두사를 결합하는 방법에는 일정한 규칙이 있으며 사용한 접두사에 따라 명령어(Instruction)가 처리하는 오퍼랜드나 어드레스의 크기에 따라 달라진다. 아래 표는 운영 모드와 접두사에 따라 오퍼랜드와 어드레스의 크기가 어떻게 변화하는지 나타낸 것이다.

|     | 리얼 모드 | 보호 모드 | IA-32e 모드(64비트 서브모드) |
| :-: | :-------: | :-------: | :--------------------------: |
| REX 접두사<br/>- IA-32e 모드 전용 | X  X  X  X | X  X  X  X | N  N  N  N   Y  Y  Y  Y |
| 오퍼랜드 크기 접두사 | N  N  Y  Y | N  N  Y  Y | N  N  Y  Y   N  N  Y  Y |
| 어드레스 크기 접두사 | N  Y  N  Y | N  Y  N  Y | N  Y  N  Y   N  Y  N  Y |
| 유효한 오퍼랜드 크기 | 16 16 32 32 | 32 32 16 16 | 32 32 16 16  64 64 64 64 |
| 유효한 어드레스 크기 | 16 32 16 32 | 32 16 32 16 | 64 32 64 32  64 32 64 32 |

위 표를 보면 IA-32e 모드의 기본 오퍼랜드 크기가 32비트로 표시된 것을 볼 수 있다.
어떤 이유에서인지는 모르겠지만 IA-32e 모드의 기본 오퍼랜드 크기는 32비트, 기본 어드레스 크기는 64비트로 설계되어 있다.
그리고 오퍼랜드가 32비트로 설계되어 어드레스를 포현할 수 없으므로 RIP 상대 어드레스라는 새로운 어드레스 계산 방식이 도입되었다.

RIP 레지스터는 현재 수행중인 명령의 어드레스를 가리키는 레지스터이다.
이름에서 알 수 있듯이 크기가 64비트이다. RIP 레지스터의 값과 32비트 오퍼랜드를 토해 64비트 주소 공간을 나타낼 수 있으며, 이것이 RIP 상대 어드레스 방시그이 어드레스 지정방법이다. 하지만 기본 오퍼랜드의 크기가 32비트이므로 RIP 레지스터의 값에 상위 2GB와 하위 2GB 범위까지만 표현할 수 있는 단점이 있다.
그래서 프로세서 제조사에서는 이런 경우를 대비하여 무조건 분기 명령어(jmp)에 예외를 두었다.
즉, 무조건 분기 명령어의 오퍼랜드의 크기는 기본 64비트로 하여 전체 어드레스 범위에서 이동이 가능하도록 한 것이다.
아래 그림은 RIP 상대 어드레스를 사용하여 표현 가능한 어드레스 영역과 무조건 분기 명령어를 사용해서 접근할 수 있는 영역에 대해 나타낸 것이다.

![](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/book/img/Ch3_img4.png)


### 세그먼트 레지스터
세그먼트 레지스터(Segment Register)는 16비트 레지스터로 어드레스 영역을 다양한 크기로 구분하는 역할을 한다.
세그먼트 레지스터의 주된 역할은 어드레스 영역의 구분이지만, 모드마다 조금씩 차이가 있다.
리얼 모드에서는 단순히 고정된 크기의 어드레스 영역을 지정하는 역할만 하지만, 보호 모드와 IA-32e 모드에서는 접근권한(Privilege Level), 세그먼트의 시작 어드레스와 크기 등을 지정하는데 사용되기도 한다.
이러한 기능을 이용하면 응용프로그램으로부터 커널 영역을 보호하는 기능을 쉽게 구현할 수 있다.

세그먼트 레지스터는 CS, DS, SS, ES, FS, GS 총 6개로 구성된다.

| 세그먼트 레지스터 이름 | 설명 |
| :--: | :-- |
| CS | 코드 영역을 가리키는 레지스터<br/>데이터 이동 명령으로 값을 변경할 수 없으며 점프 명령이나 인터럼트 과련 명령으로 변경 가능 |
| DS, ES, FS, GS | 데이터 영역을 가리키는 레지스터<br/>데이터 이동명령으로 값을 변경할 수 있음<br/>DS 레지스터는 데이터 영역에 접근할 때 암시적으로 사용됨<br/>데이터 영역에 접근하면서 DS레지스터 이외의 세그먼트 레지스터를 사용하려면 세그먼트 레지스터 접두사 사용 |
| SS | 스택 영역을 가리키는 레지스터<br/>데이터 이동 명령으로 값을 변경할 수 있음<br/>스택 관련 레지스터(SP, BP)를 통해 스택에 접근할 때 암시적으로 사용된다. |

세그먼트 레지스터에는 DS, ES, FS, GS 와 같이 총 4개의 데이터 관련 세그먼트 레지스터가 있으며, 세그먼트 레지스터 접두사를 통해 명시적으로 특정 세그먼트를 설정할 수 있다.
명시적으로 지정하지 않으면 기본적으로 사용되는 세그먼트 레지스터는 위 표에서 보는것과 같다.

세그먼트 레지스터의 역할은 주소 공간을 목적에 따라 구분하는 것이며, 주소 공간을 구분하는 방법은 메모리 관리 기법과 깊은 관계가 있다. 메모리 관리 기법에는 크게 세그멘테이션 기법, 페이징 기법 두 가지가 있다.
이중에서 세그먼트 레지스터를 통해 주소 공간을 구분하는 방식이 세그멘테이션이다.

### 컨트롤 레지스터
컨트롤 레지스터(Control Register)는 운영모드를 변경하고, 현재 운영중인 모드의 특정 기능을 제어하는 레지스터이다.
x86 프로세서에서는 CR0, CR1, CR2, CR3, CR4의 5개의 컨트롤 레지스터가 존재하며, x86-64프로세서에는 CR8이 추가되어 총 6개의 컨트롤 레지스터가 있다.

| 컨트로 레지스터 | 설명 |
| :--: | :-- |
| CR0 | 운영 모드를 제어하는 레지스터<br/>리얼 모드에서 보호 모드로 전환하는 역할과 캐시, 페이징 기능 등을 활성시킨다. |
| CR1 | 프로세서에 의해 예약된 레지스터 |
| CR2 | 페이지 폴트 발생 시 페이지 폴트가 발생한 선형 주소가 저장되는 레지스터<br/>페이징 기법을 활성화한 후에는 페이지 폴트 발생 시만 유효한 값을 가진다. |
| CR3 | 페이지 디렉터리의 물리 주소와 페이 ㅣ 캐시에 관련된 기능을 설정하는 레지스터 |
| CR4 | 프로세서에서 지원하는 각종 확장 기능을 제어하는 레지스터<br/>페이지 크기 확장이나 메모리 영역 확장 등의 기능을 활성시킨다. |
| CR8 | 태스크 우선순위 레지스터의 값을 제어하는 레지스터<br/>프로세스 외부에서 발생하는 인터럽트를 걸러주는 필터의 역활<br/>IA-32e 모드에서만 접근 가능 |

컨트롤 레지스터는 리얼 모드와 보호 모드일 때 32비트 크기이며, IA-32e 모드에서는 64비트로 확장되지만 일부 제약사항이 있다.
CR0, CR4, CR8 레지스터에서는 64비트 중 상위 32비트를 0으로 설정해야 한다.
CR2레지스터의 경우는 64비트 영역을 모두 사용할 수 있으며, CR3 레지스터는 비트 40부터 비트 51까지 모두 0으로 설정해야한다.

컨트롤 레지스터는 프로세스의 운영 모드와 확장 기능를 제어하는 레지스터인 만큼 아래 그림처럼 구조가 복잡하다.
각 필드는 저마다 특정 기능을 활성/비활성화하며, 현재 운영 모드에 따라 필수 필드와 옵션 필드가 달라진다.
컨트롤 레지스터의 특정 기능은 해당 비트를 1로 설정해도 충분하지만, 특정 기능은 1로 설정하기 전에 프로세서가 사용할 자료구조를 미리 준비해야 한다.
조건을 충족하지 못했다면 시스템은 재부팅되거나 먹통이 되곤 한다.

![](https://github.com/HIPERCUBE/64bit-Multicore-OS/blob/master/book/img/Ch3_img5.png)

지금까지 x86-64 프로세서의 운영 모드와 레지스터를 중심으로 살펴보았다.
이 부분을 OS를 만들 때 곡 알아둬야 하는 부분이며, 각 필드에 대해 세세하게 알 필요는 없지만 적어도 세그먼트 레지스터와 컨트롤 레지스터들이 어떤 역활을 하고 어떤 용도로 사용되는지 알아야 한다.

## 운영 모드와 메모리 관리 기법
x86과 x86-64 프로세서에서 지원하는 메모리 관리 기법은 크게 두 가지가 있다.
한 가지는 세그멘테이션(Segmentation)이고, 다른 한 가지는 페이징(Paging)이다.
세그멘테이션과 페이징은 주소 공간을 특정 영역으로 나눈다는 공통점이 있지만, 나누는 방식에 차이가 있다.
세그멘테이션은 전체 영역을 원하는 크기로 나누어 관리하는 방식이고, 페이징은 일정한 단위로 잘라서 조각을 모아 원하는 크기로 관리하는 방식이다.
메모리 관리 기법을 사용하려면 과련 레지스터에 특정한 자료구조를 설정해야 한다.
세그멘테이션은 세그먼트 레지스터에 세그먼트의 시작 주소 혹은 디스크립터(Descriptor)라고 불리는 자료구조의 위치를 설정해야 한다.
페이징은 컨트롤 레지스터 중에 CR3 레지스터에 페이지 디렉터리라고 불리는 자료구조의 물리 주소를 설정해야 사용이 가능하다.
그리고 모든 운영모드가 세그먼트와 페이징을 지원하는 것은 아니고 모드에 따라 지원하지 않거나 지원하지만 일부 기능이 제한되는 경우도 있다.
이러한 차이는 x86-64 프로세서가 기존 프로세서와 호환성을 유지하면서 발전했기 때문이다.
